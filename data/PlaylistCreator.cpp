/*
 * Copyright (C) 2004  Norbert Drees, Norbert.Drees@GMX.de
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
#include "ScannerLibrary/ScannerFunctions.h"

#include "defines.h"
#include "PlaylistCreator.h"

using namespace std;
using namespace ScannerLibrary;

//----------------------------------------------------------------------------
PlaylistCreator::PlaylistCreator( const std::string & directory, const std::string & playlist, const bool forceGeneration  )
: Scanner( directory, Short )
, nPlaylists( 0 )
, nNewPlaylists( 0 )
, thePlaylist( playlist )
, theForceGeneration( forceGeneration )
{
  if( thePlaylist == string() )
  {
    thePlaylist = Playlist;
  }
}
//----------------------------------------------------------------------------
PlaylistCreator::~PlaylistCreator()
{
}
//----------------------------------------------------------------------------
void PlaylistCreator::startScanning()
{
  nPlaylists = 0;
  nNewPlaylists = 0;
  Scanner::startScanning();
}
//----------------------------------------------------------------------------
void PlaylistCreator::onEndScanning()
{
  ::fprintf( stderr, "\n" );
  ::fprintf( stderr, "MP3 files found    : %d\n", getNumberOfFiles() );
  ::fprintf( stderr, "M3U files created  : %d\n", nNewPlaylists );
  ::fprintf( stderr, "M3U files complete : %d\n", nPlaylists );
}
//----------------------------------------------------------------------------
void PlaylistCreator::onEnterDirectory()
{
  ::fprintf( stderr, "%c", EnterDirectory );
}
//----------------------------------------------------------------------------
void PlaylistCreator::onFoundFiles( const ScannerLibrary::tStringList & files )
{
  const string theDirectory = getCurrentDirectory();
  if( theDirectory != string() )
  {
    const string playlist( theDirectory + "\\" + thePlaylist );

    unsigned int theOldChecksum = 0;
    unsigned int theNewChecksum = 0;

    // build new content for playlist file
    string theData( "# Generated by " Program " " Version );
    theData += "\n";
    theData += "# Copyright (C) " Author;
    theData += "\n";
    for( unsigned int i = 0; i < files.size(); i++ )
    {
      theData += files[i];
      theData += "\n";
    }

    // if we have to check the checksum from existing
    // file against new playlist file data
    if( ! theForceGeneration )
    {
      // will be created from existing file
      theOldChecksum = getChecksumFormFile( playlist );
      // will be created from created string
      theNewChecksum = createChecksum( theData );
    }

    if( theForceGeneration || (theNewChecksum != theOldChecksum) )
    {
      FILE * theFile = ::fopen( playlist.c_str(), "w" );
      if( theFile != NULL )
      {
        ::fprintf( stderr, "%c", WritePlaylist );
        nNewPlaylists++;
        fprintf( theFile, "%s", theData.c_str() );

        int theError = ::fclose( theFile );
        if( theError != 0 )
        {
          error( Short, getErrorMessage( theError ) );
        }
      }
      else
      {
        error( Short, "Couldn't create playlist in " + theDirectory );
      }
    }
    else
    {
      ::fprintf( stderr, "%c", PlaylistUnchanged );
    }

    nPlaylists++;
  }
}
//----------------------------------------------------------------------------
const unsigned int PlaylistCreator::getChecksumFormFile( const std::string & playlist ) const
{
  string theChecksumString( "" );

  // IMPORTANT! Open the file in binary mode! We need a chance to filter
  //            the carrige return.
  FILE * pFile = ::fopen( playlist.c_str(), "rb" );
  if( pFile != NULL )
  {
    int theError = ::fseek( pFile, 0, SEEK_END );
    if( theError != 0 )
    {
      error( Short, getErrorMessage( theError ) );
      ::fclose( pFile );
      return 0; // couldn't calculate checksum
    }

    long theLength = ::ftell( pFile );

    // seek back to the beginning 
    theError = ::fseek( pFile, -theLength, SEEK_CUR );
    if( theError != 0 )
    {
      error( Short, getErrorMessage( theError ) );
      ::fclose( pFile );
      return 0; // couldn't calculate checksum
    }

    // scan file and build checksum string
    for( long i = 0; i < theLength; i++ )
    {
      const char theCharacter = ::fgetc( pFile );
      if( theCharacter != '\r' ) // ignore the damned carriage return
      {
        theChecksumString += theCharacter;
      }
    }
    
    theError = ::fclose( pFile );
    if( theError != 0 )
    {
      // do not return! we have what we want
      error( Short, getErrorMessage( theError ) );
    }

    // finally create the checksum
    return createChecksum( theChecksumString );
  }

  // no file -> no checksum
  return 0;
}
//----------------------------------------------------------------------------
const unsigned int PlaylistCreator::createChecksum( const std::string & value ) const
{
  unsigned int theChecksum = 0;
  for( unsigned int i = 0; i < value.size(); i++ )
  {
    theChecksum += static_cast<unsigned int>( value[i] );
  }
  return theChecksum;
}
//----------------------------------------------------------------------------